create table tb_article
(
    id             varchar(42)  not null comment 'ID'
        primary key,
    author_id      varchar(32)  null comment '作者id',
    title          varchar(128) null comment '标题',
    description    varchar(255) null comment '描述',
    content        text         null comment '内容',
    cover          varchar(512) null comment '封面',
    sort_id        int          null comment '分类id',
    alter_date     datetime     null comment '修改日期',
    create_date    datetime     not null comment '创建日期',
    likes_number   int          null comment '点赞数量',
    reads_number   int          null comment '阅读数量',
    comment_number int          null comment '评论数量',
    state          int          null comment '文章状态，0审核，1通过，2退回，3保存，-1锁定',
    label          varchar(128) null comment '标签 '
)
    collate = utf8_bin;

INSERT INTO JwssNet.tb_article (id, author_id, title, description, content, cover, sort_id, alter_date, create_date, likes_number, reads_number, comment_number, state, label) VALUES ('0', 'fe3e948ce7b74064909c104234ba65c2', '原神7-1怎么打', '开场水冰2胖子-水雷冰3胖子，冰+雷练度够任意法术输出也行强秒水胖。输出不够冰胖跳过来后开盾直接用安柏大招打晕，然后继续输出水胖。', '<p>开场水冰2胖子-水雷冰3胖子，冰+雷练度够任意法术输出也行强秒水胖。输出不够冰胖跳过来后开盾直接用安柏大招打晕，然后继续输出水胖。</p><p><img alt="原神7-1怎么打" src="https://img.18183.com/uploads/allimg/201126/327-201126154545.jpg@!18183"></p><p><strong>原神7-1怎么打</strong></p><p><strong>打法一:开场水冰2胖子-水雷冰3胖子</strong></p><p>冰水2胖</p><p>冰+雷【练度够任意法术输出也行】强秒水胖。</p><p>【输出不够冰胖跳过来后开盾直接用安柏大招打晕】然后继续输出水胖。</p><p>水胖死后打死冰胖即可，开盾就用安柏或者任意火解。</p><p>水雷冰3胖</p><p>依旧强秒水胖，出现位置和上一只照旧，中间会多个雷胖，雷胖技能很慢最后打。</p><p>水冰胖死后。</p><p>冰破雷胖盾强打死即可。</p><p><strong>打法二:冰胖+火瘦 冰风胖+火瘦</strong></p><p>冰胖+火瘦</p><p>伤害够强杀火瘦，慢慢打死冰胖即可。</p><p>冰风胖+火瘦</p><p>先杀冰胖-火瘦 用aoe打死风胖即可。</p><p>【最好先杀冰胖，配合风胖吸人喷冰容易减员】</p>', '/res/cover/7f8680a3a9737d32a94905d2d9ef2415.jpg', 0, '2020-12-26 13:37:45', '2020-11-26 16:22:02', 0, 0, 0, 0, '原神');
INSERT INTO JwssNet.tb_article (id, author_id, title, description, content, cover, sort_id, alter_date, create_date, likes_number, reads_number, comment_number, state, label) VALUES ('auu09c2ce5946404faab023c54ca9c1d57c', 'fe3e948ce7b74064909c104234ba65c2', '各品牌奶茶加盟费', '奶茶加盟一向是各保守型智慧之选者的智慧之选优选，不过，市面上已成规模和气候的奶茶品牌极多，如何才能选择到合适的品牌呢？', '<p>奶茶加盟一向是各保守型智慧之选者的智慧之选优选，不过，市面上已成规模和气候的奶茶品牌极多，如何才能选择到合适的品牌呢？一方面看品牌知名度和影响力，另一方面看加盟费与加盟售后服务。为此，小编整理了一些智慧之选价值较高的品牌，为您介绍加盟费问题。<strong>各品牌奶茶加盟费</strong>情况如何，我们一起来看下吧。</p><p><img alt="奶茶" src="https://www.tameng.com/Upload/20201128/qaw6o2bl9fe.jpg"><br></p><p><strong>1、蜜逗鲜饮奶茶</strong></p><p>品牌介绍：长沙润茶餐饮管理有限公司旗下品牌，集时尚、进口、多元、创立元素与一体，拥有多样化菜品可选。蜜逗鲜饮奶茶经营产品系列有：港式甜品、乐活鲜饮、奶茶、可可抹茶、鲜榨果汁、冰淇淋、冰沙奶昔等。</p><p>加盟费：1—5万元</p><p><strong>2、奉茶</strong></p><p>品牌介绍：奉茶一直坚持的原则，是以新鲜、健康的好食材来精心制作每一杯产品，以季节性水果与新鲜牛奶为搭配，口感清新美味。同时奉茶的产品设计又是时尚新颖有创意的，在年轻人之间很有人气。</p><p>加盟费：10—20万元</p><p><img alt="奶茶" src="https://www.tameng.com/Upload/20201128/cn1oumzswiy.jpg"><br></p><p><strong>3、茶未里奶茶</strong></p><p>品牌介绍：茶未里是在奶茶产品同质化严重的形势下确立的全新项目，不管是原材料还是饮品制作工艺，抑或是产品形态，茶未里都有所突破。茶未里奶茶精选全国八款茶叶作为基底，以绿色健康的果蔬食材为辅料，细切、冰滴等技术，研制出的一款颜值高、口感好的高品质时尚茶饮。</p><p>加盟费：1—5万元</p><p><strong></strong><strong>4、吾饮合格品</strong></p><p>品牌介绍：武汉吾饮合格品餐饮管理有限公司旗下港式潮饮品牌，以独树一帜的“港式潮饮”特色定位，“年轻、时尚、潮流”的气息深入人心，外加专业的培训制度、严格的原料供应体系及完善的物流体系，使其迅速从众多同行业竞争品牌中脱颖而出。</p><p>加盟费：10—20万元</p><p><strong>5、黑泷堂</strong></p><p>品牌介绍：专业茶饮品牌，瑞里餐饮管理有限公司旗下知名品牌。黑泷堂产品拥有统一的视觉、嗅觉和味觉体验，一杯好茶，浓浓情意，深受大众喜爱。</p><p>加盟费：5—10万元</p><p><img alt="奶茶" src="https://www.tameng.com/Upload/20201128/aljpezsw6o5.jpg"><br></p><p>各品牌奶茶加盟费多少？以上是部分奶茶品牌加盟费情况的介绍。市场上还有许多值得智慧之选的奶茶品牌，加盟费也在10万元作用徘徊，如果您想进一步了解，请给我们留言。</p>', '/res/cover/502db85d52e9d79d7d17e409b8593f2c.jpg', 0, '2020-12-26 13:53:46', '2020-11-29 14:28:03', 0, 0, 0, 0, '奶茶');
INSERT INTO JwssNet.tb_article (id, author_id, title, description, content, cover, sort_id, alter_date, create_date, likes_number, reads_number, comment_number, state, label) VALUES ('auu3cc1985682d74e6885853294b06e492d', '486d4e94fc9f46cbac5166eb8e0263aa', '【设计模式】Java常用设计模式之单例模式', null, '<h2>前言</h2><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<strong>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象</strong>。</p><h2><a href="http://www.vjwss.top/detail/Java/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0"></a>单例模式实现</h2><p>1、首先我们得有个SingleObj类</p><figure><table><tbody><tr><td><pre>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br></pre></td><td><button><i></i>COPY</button><pre>publicclassSingleObj{<br>privatestaticSingleObj instance =newSingleObj();//创建一个SingleObj<br><br>// 使用私有构造方法，外部就不能直接创建改类<br>privateSingleObj(){}<br><br>// 通过该方法获取到对象实例<br>publicstaticSingleObjgetInstance(){<br>returninstance;<br>}<br><br>publicvoidsayHello(){<br>System.out.println("Hello,SingleObj!!!");<br>}<br>}<br></pre></td></tr></tbody></table></figure><p>2、创建SingleObj对象并且调用sayHello()方法</p><figure><table><tbody><tr><td><pre>1<br>2<br>3<br>4<br>5<br>6<br></pre></td><td><button><i></i>COPY</button><pre>publicclassApp{<br>publicstaticvoidmain(String[] args){<br>SingleObj singleObj = SingleObj.getInstance();<br>singleObj.sayHello();<br>}<br>}<br></pre></td></tr></tbody></table></figure><figure><table><tbody><tr><td><pre>1<br></pre></td><td><button><i></i>COPY</button><pre>控制台输出：Hello,SingleObj!!!<br></pre></td></tr></tbody></table></figure><h2><a href="http://www.vjwss.top/detail/Java/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html#%E5%B8%B8%E8%A7%81%E7%9A%845%E7%A7%8D%E5%86%99%E6%B3%95"></a>常见的5种写法</h2><h3><a href="http://www.vjwss.top/detail/Java/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html#1%E3%80%81%E6%87%92%E6%B1%89%E5%BC%8F"></a>1、懒汉式</h3><ul><li>缺点：线程不安全</li><li>实现难度：易</li><li>是否Lazy：是</li><li>是否多线程安全：否</li></ul><figure><table><tbody><tr><td><pre>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br></pre></td><td><button><i></i>COPY</button><pre>publicclassSingleLanHan{<br>privateSingleLanHan(){}<br><br>privatestaticSingleLanHan instance;<br><br>publicstaticSingleLanHangetInstance(){<br>if(instance ==null){<br>returnnewSingleLanHan();<br>}<br>returninstance;<br>}<br><br>publicvoidsayHi(){<br>System.out.println("Hi,SingleLanHan!!!");<br>}<br>}<br></pre></td></tr></tbody></table></figure><h3><a href="http://www.vjwss.top/detail/Java/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html#2%E3%80%81%E8%B5%96%E6%B1%89%E5%BC%8F"></a>2、赖汉式</h3><ul><li>优点：第一次调用才初始化，避免浪费内存</li><li>缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。</li><li>实现难度：易</li><li>是否Lazy：是</li><li>是否多线程安全：是</li></ul><figure><table><tbody><tr><td><pre>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br></pre></td><td><button><i></i>COPY</button><pre>publicclassSingleLanHanSave{<br>privateSingleLanHanSave(){}<br><br>privatestaticSingleLanHanSave instance;<br><br>publicstaticsynchronizedSingleLanHanSavegetInstance(){<br>if(instance ==null){<br>returnnewSingleLanHanSave();<br>}<br>returninstance;<br>}<br><br>publicvoidsayHi(){<br>System.out.println("Hi,SingleLanHanSave!!!");<br>}<br>}<br></pre></td></tr></tbody></table></figure><h3><a href="http://www.vjwss.top/detail/Java/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html#3%E3%80%81%E9%A5%BF%E6%B1%89%E5%BC%8F%EF%BC%88%E6%AF%94%E8%BE%83%E5%B8%B8%E7%94%A8%EF%BC%89"></a>3、饿汉式（比较常用）</h3><ul><li>优点：没有加锁，执行效率会提高</li><li>缺点：类加载时就初始化，浪费内存</li><li>实现难度：易</li><li>是否Lazy：否</li><li>是否多线程安全：是</li></ul><figure><table><tbody><tr><td><pre>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br></pre></td><td><button><i></i>COPY</button><pre>publicclassErHan{<br>privatestaticErHan instance =newErHan();<br>privateErHan(){}<br>publicstaticErHangetInstance(){<br>returninstance;<br>}<br>publicvoidsayHello(){<br>System.out.println("Hello,ErHan!!!");<br>}<br>}<br></pre></td></tr></tbody></table></figure><h3><a href="http://www.vjwss.top/detail/Java/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html#4%E3%80%81%E5%8F%8C%E6%A3%80%E9%94%81-%E5%8F%8C%E9%87%8D%E6%A0%A1%E9%AA%8C%E9%94%81%EF%BC%88DCL%EF%BC%8C%E5%8D%B3-double-checked-locking%EF%BC%89"></a>4、双检锁/双重校验锁（DCL，即 double-checked locking）</h3><ul><li>优点：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。</li><li>实现难度：较复杂</li><li>是否Lazy：是</li><li>是否多线程安全：是</li></ul><figure><table><tbody><tr><td><pre>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br></pre></td><td><button><i></i>COPY</button><pre>publicclassSingleDCL{<br>privatevolatilestaticSingleDCL instance;<br><br>privateSingleDCL(){}<br><br>publicstaticSingleDCLgetInstance(){<br>if(instance ==null){<br>synchronized(SingleDCL.class){<br>instance =newSingleDCL();<br>}<br>}<br>returninstance;<br>}<br><br>publicvoidsayHello(){<br>System.out.println("Hello,SingleDCL!!!");<br>}<br>}<br></pre></td></tr></tbody></table></figure><h3><a href="http://www.vjwss.top/detail/Java/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html#5%E3%80%81%E6%9E%9A%E4%B8%BE"></a>5、枚举</h3><ul><li>实现难度：易</li><li>是否Lazy：否</li><li>是否多线程安全：是</li></ul><figure><table><tbody><tr><td><pre>1<br>2<br>3<br>4<br>5<br>6<br></pre></td><td><button><i></i>COPY</button><pre>publicenumSingleEnum {<br>INSTANCE;<br>publicvoidsayHi(){<br>System.out.println("Hi,SingleEnum!!!");<br>}<br>}<br></pre></td></tr></tbody></table></figure><p><strong>描述：</strong>这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。不能通过 reflection attack 来调用私有构造方法。</p><h2><a href="http://www.vjwss.top/detail/Java/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html#%E6%80%BB%E7%BB%93"></a>总结</h2><p>先对上面的代码进行总的调用</p><figure><table><tbody><tr><td><pre>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br></pre></td><td><button><i></i>COPY</button><pre>publicclassApp{<br>publicstaticvoidmain(String[] args){<br>//懒汉式（线程不安全）<br>SingleLanHan singleLanHan = SingleLanHan.getInstance();<br>singleLanHan.sayHi();<br><br>//懒汉式（线程安全）<br>SingleLanHanSave singleLanHanSave = SingleLanHanSave.getInstance();<br>singleLanHanSave.sayHi();<br><br>//饿汉式<br>SingleErHan singleErHan = SingleErHan.getInstance();<br>singleErHan.sayHello();<br><br>//双检锁/双重校验锁<br>SingleDCL singleDCL =  SingleDCL.getInstance();<br>singleDCL.sayHello();<br><br>//枚举<br>SingleEnum singleEnum = SingleEnum.INSTANCE;<br>singleEnum.sayHi();<br>}<br>}<br></pre></td></tr></tbody></table></figure><figure><table><tbody><tr><td><pre>1<br>2<br>3<br>4<br>5<br></pre></td><td><button><i></i>COPY</button><pre>Hi,SingleLanHan!!!<br>Hi,SingleLanHanSave!!!<br>Hello,ErHan!!!<br>Hello,SingleDCL!!!<br>Hi,SingleEnum!!!<br></pre></td></tr></tbody></table></figure><p>总的来说，个人是比较推荐的是饿汉式和枚举，但常用的还是 饿汉式。凡是都有例外，按需求去实现。</p><p>网上有很多设计模式的文章，我这里只是对网络上文章的学习而做个总结，如有建议或疑问请通过以下公众号方式发送消息。</p>', null, 1, null, '2021-02-26 16:55:28', 0, 1, 0, 0, null);
INSERT INTO JwssNet.tb_article (id, author_id, title, description, content, cover, sort_id, alter_date, create_date, likes_number, reads_number, comment_number, state, label) VALUES ('auu68a8204873894cea8ee29eb03af39823', 'fe3e948ce7b74064909c104234ba65c2', '解决Layui数据表格中checkbox位置不居中', '使用方法渲染的方式生成数据表格，添加了checkbox，但发现checkbox位置不居中，如下图所示', '<h3>1.情景</h3><p>使用方法渲染的方式生成数据表格，添加了checkbox，但发现checkbox位置不居中，如下图所示<img alt="checkbox位置不居中" src="https://img-blog.csdn.net/20180120172445835"></p><p><br></p><h3><a></a><a></a>2.解决办法</h3><p>通过layui官方社区，找到如下代码，只需要添加如下样式即可解决</p><pre><code><ol><li><p><br></p><p>&lt;style&gt;</p></li><li><p><br></p><p>.layui-table-cell.layui-form-checkbox[lay-skin="primary"]{</p></li><li><p><br></p><p>top:50%;</p></li><li><p><br></p><p>transform:translateY(-50%);</p></li><li><p><br></p><p>}</p></li><li><p><br></p><p>&lt;/style&gt;</p></li></ol></code></pre><p>--------------------- 本文来自 xcmercy 的CSDN 博客 ，全文地址请点击：https://blog.csdn.net/cccmercy/article/details/79115550?utm_source=copy</p>', '/res/cover/4a3e1f0e93d59c4435aca7a83fe51e64.jpg', 0, '2020-12-26 13:28:11', '2020-12-10 15:42:15', 0, 0, 0, 0, 'layui,前端');
INSERT INTO JwssNet.tb_article (id, author_id, title, description, content, cover, sort_id, alter_date, create_date, likes_number, reads_number, comment_number, state, label) VALUES ('auub664f4ad28da411ba21ab0a8e01eee34', 'fe3e948ce7b74064909c104234ba65c2', '如何评价游戏《生化危机7》？', '除了第一人称视角和剧情，这就是老玩家熟悉的《生化危机》。如果可以的话，我更想在玩到所有DLC后再给《生化7》评分。因为若是能再打磨一下或是包含更多的内容，它带给玩家的体验一定比现在要好得多。', '<blockquote><b>无论如何，Capcom所做出的大胆挑战确实让人肃然起敬，而系列究竟能否在摆脱曾经的固步自封后再创辉煌，终究取决于玩家间的反应。</b></blockquote><p>除了第一人称视角和剧情，这就是老玩家熟悉的《生化危机》。如果可以的话，我更想在玩到所有DLC后再给《生化7》评分。因为若是能再打磨一下或是包含更多的内容，它带给玩家的体验一定比现在要好得多。</p><p><b>注：本评测的图文皆不含剧透，尚未通关的玩家可放心观看。</b></p><p>从《生化危机7》于2016年E3游戏展首次公开起，“这不是《生化危机》”的声音就从未停息过。第一人称视角、陌生的环境和角色、让人摸不着头脑的概念试玩……官方在宣传时的刻意隐藏和反复更新的DEMO让7代一直保持着神秘感和话题性，直到玩家真正拿到游戏。</p><p>4代的革命性分水岭让“《生化》系列”拥有着喜好截然不同的玩家群体，自三上真司离去后，5代弄死人气大反派威斯克、6代好莱坞大片式的群像剧都令其饱受质疑，但即便如此，它们还是分别卖出了710万套和660万套，成为系列最好的销售成绩。</p><p>Capcom比玩家们更清楚，这个发展20年、全系列累计销量7100万套的头号招牌不容有失。固步自封用老角色卖情怀、以老套路迎合玩家口味继续开发固然风险更低，但他们却选择了迈出革命性的一步……</p><figure><noscript><img src="https://pic4.zhimg.com/50/v2-41bdc47498bcf2fe5681db06bea08e0c_hd.jpg?source=1940ef5c"/></noscript><img src="https://pic4.zhimg.com/80/v2-41bdc47498bcf2fe5681db06bea08e0c_720w.jpg?source=1940ef5c"></figure><p></p><p><i>在评测开始前，让我们暂时先忘记最受争议的第一人称视角。</i></p>', '/res/cover/a91ab1b619a2d84df8c1ce6a668c6524.jpg', 0, '2020-12-26 13:47:10', '2020-11-27 16:09:23', 0, 0, 0, 0, '生化危机');